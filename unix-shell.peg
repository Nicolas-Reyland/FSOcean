/*
 * Grammar for simple unix shell
 */

VALUE-SEPARATOR (P1, P2) => P1 (P2 P1)*

// Concrete

SHELL-INSTRUCTION   := VALUE-SEPARATOR(COMMAND CMD-SEP)

COMMAND             := COMMAND-UNIT REDIRECT
COMMAND-UNIT        := SCOPE-COMMAND | CLASSIC-COMMAND
CLASSIC-COMMAND     := COMMAND-PREFIX NAMES
// horrible name

COMMAND-PREFIX      := (LITERAL "=" NAME)*
SCOPE-COMMAND       := IF-STATEMENT | FOR-LOOP | WHILE-LOOP | UNTIL-LOOP | CASE-STATEMENT

NAME                := LITERAL | DOUBLEQ | SINGLEQ
NAMES               := NAME NAME*

REDIRECT            := (REDIRECT-IN | REDIRECT-OUT)*
REDIRECT-IN-SIMPLE  := ("<" "<"?) LITERAL
REDIRECT-OUT-SIMPLE := (">" ">"?) LITERAL

CMD-SEP             := PIPE | AMP | NEW-CMD
PIPE                := "|" "|"?
AMP                 := "&" "&"?
NEW-CMD             := ";" | "\n"

LITERAL             := LITERAL
DOUBLEQ             := DOUBLEQ
SINGLEQ             := SINGLEQ

IF-STATEMENT        := "if" IF-COND-ACTION (IF-ALTERNATIVE CMD-SEP)* "fi"
IF-COND-ACTION      := NAMES NEW-CMD "then" ONL SHELL-INSTRUCTION NEW-CMD
IF-ALTERNATIVE      := ("else" "\n" SHELL-INSTRUCTION CMD-SEP) | ("elif" IF-COND-ACTION)
FOR-LOOP            := "for" LITERAL ("in" NAMES)? LOOP-BODY
WHILE-LOOP          := "while" COMMAND LOOP-BODY
UNTIL-LOOP          := "until" COMMAND LOOP-BODY
LOOP-BODY           := NEW-CMD "do" ONL SHELL-INSTRUCTION NEW-CMD "done"
CASE-STATEMENT      := "case" LITERAL "in" ((VALUE-SEPARATOR(CASE-EXPR, ";;") ((ONL ";;" ONL) | "\n")) | "\n")? esac"
CASE-EXPR           := ONL "("? VALUE-SEPARATOR(NAME, "|") ")" ONL SHELL-INSTRUCTION

ONL                 := "\n"?



// Keep in mind

LITERAL:
    FILENAME        := STRING
    SUB-COMMAND     := "$(" COMMAND ")"
    VAR             := "$" STRING
    VAR-SUBST       := "${" STRING (":" STRING)* "}"
    VAR-SET         := STRING "=" STRING | SUB-COMMAND | VAR | VAR-SUBST | VAR-SET | DOUBLEQ | SINGLEQ
